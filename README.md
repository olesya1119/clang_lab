# Преобразование и анализ кода с использованием Clang и LLVM

<b>Цель работы:</b> Познакомиться с инструментами Clang и LLVM, научиться собирать AST и IR-промежуточное представление кода на C/C++, а также извлекать базовую информацию о программе.

## Задачи: 

1. Установить Clang и LLVM;

2. Скомпилировать простой C-файл с использованием clang и получить его: абстрактное синтаксическое дерево (AST), промежуточное представление LLVM IR;

3. Использовать opt для применения базовой комплексной оптимизации (например, О2);

4. Построить граф потока управления (CFG) для оптимизированной программы;

5. Проанализировать результат, сделать выводы и ответить на контрольные вопросы.

## Ход работы
### 1. Установка и подготовка среды

Работа выполнялась в среде Ubuntu 22.04(WSL).

Установлены следующие инструменты:
- `clang` — компилятор языка C/C++;
- `llvm` — инструменты анализа и оптимизации кода;
- `opt` — инструмент для работы с LLVM IR и применения оптимизаций;
- `Graphviz` — инструмент для визуализации кода.  

```bash
sudo apt install clang llvm graphviz
```
![image](https://github.com/user-attachments/assets/1fecd313-4c10-4bb5-940d-31a7304e0a05)


### 2. Исходный код
```C
#include <stdio.h>
int square(int x) {
 return x * x;
}
int main() {
 int a = 5;
 int b = square(a);
 printf("%d\n", b);
 return 0;
}
```
![image](https://github.com/user-attachments/assets/4ad150cd-4d1a-41b9-ad8c-a6cb9875b31a)



### 3. Получение AST

```bash
clang -Xclang -ast-dump -fsyntax-only main.c
```
![image](https://github.com/user-attachments/assets/72325775-c7b1-49ea-bc25-6a824f854241)

Видим что функция square int (int) - прнимает int x и возвращает int x * x


### 4. Генерация LLVM IR

```bash
clang -S -emit-llvm main.c -o main.ll
```
![image](https://github.com/user-attachments/assets/3257ae26-cb93-4673-9e23-331b2bf1d133)

### 5. Оптимизация IR


```bash
clang -O0 -S -emit-llvm main.c -o main_O0.ll
```
![image](https://github.com/user-attachments/assets/2fe8cbe6-5517-4b2d-a417-6c5c9e973f08)

```bash
clang -O2 -S -emit-llvm main.c -o main_O2.ll
```
![image](https://github.com/user-attachments/assets/33907110-1649-45e7-9775-724fbee71e58)

Сравнение (diff):
```bash
diff main_O0.ll main_O2.ll
```
![image](https://github.com/user-attachments/assets/313fd578-1c9c-48b4-bd0a-e2aacca82c8c)

Основные изменения:
#### 1. Удаление лишних операцией работы с памятью, по сути осталось только операция умножения - mul

До:
```
define dso_local i32 @square(i32 noundef %0) #0 {
  %2 = alloca i32, align 4
  store i32 %0, ptr %2, align 4
  %3 = load i32, ptr %2, align 4
  %4 = load i32, ptr %2, align 4
  %5 = mul nsw i32 %3, %4
  ret i32 %5
}
```

После:
```
define dso_local i32 @square(i32 noundef %0) local_unnamed_addr #0 {
  %2 = mul nsw i32 %0, %0
  ret i32 %2
}
```

#### 2. Встраивание результата функции square в main (сразу вычислилось значение 25)
   
До:
```
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  store i32 0, ptr %1, align 4
  store i32 5, ptr %2, align 4
  %4 = load i32, ptr %2, align 4
  %5 = call i32 @square(i32 noundef %4)
  store i32 %5, ptr %3, align 4
  %6 = load i32, ptr %3, align 4
  %7 = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %6)
  ret i32 0
}
```

После:
```
define dso_local noundef i32 @main() local_unnamed_addr #1 {
  %1 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull @.str, i32 noundef 25)
  ret i32 0
}
```



### 6. Граф потока управления программы

```bash
opt -passes=dot-cfg -disable-output main_O2.ll
dot -Tpng .main.dot -o cfg_main.png
dot -Tpng .square.dot -o cfg_square.png
```
![cfg_main](https://github.com/user-attachments/assets/5c64adc0-2b9b-4170-881c-7e35a5b624e3)

![cfg_square](https://github.com/user-attachments/assets/f0c6b639-1cbf-4ed6-9e45-bf25b6c7d80c)


Результат:

- Граф для `main` содержит один блок (после оптимизации).

- Граф для `square` показывает блок с операцией `mul`.

Вывод:
CFG наглядно демонстрирует упрощение потока управления после оптимизаций.

### Выводы по работе
- Clang — обеспечивает глубокий статический анализ кода через AST (Abstract Syntax Tree) и IR (Intermediate Representation), позволяя исследовать структуру программы и семантику на разных уровнях абстракции.

- Оптимизации LLVM (уровень -O2) — агрессивно трансформируют промежуточное представление (IR), устраняя мертвый код, сводя вычисления к константам и упрощая графы выражений для повышения эффективности.

- Граф управления потоком (CFG) — визуализирует логику выполнения программы, отображая базовые блоки и переходы между ними, что критично для анализа доминаторов, обнаружения циклов и оптимизации условий.



# Ответы на контрольные вопросы

## 1. Что такое Clang, и какова его роль в процессе компиляции программ?

**Clang** - это фронтенд-компилятор для языков C, C++ и Objective-C, разработанный как часть проекта LLVM. Его ключевые функции:

- Лексический и синтаксический анализ исходного кода
- Построение абстрактного синтаксического дерева (AST)
- Семантический анализ (проверка типов, областей видимости)
- Генерация промежуточного представления LLVM IR
- Интеграция с инструментами LLVM для дальнейшей оптимизации

## 2. Что представляет собой LLVM и как он используется в современных компиляторах?

**LLVM** (Low Level Virtual Machine) - это инфраструктура для создания компиляторов, включающая:

- Универсальное промежуточное представление (IR)
- Набор инструментов для оптимизации кода
- Генераторы машинного кода для различных архитектур

Используется в компиляторах Clang (C/C++), Rust, Swift и других как бэкенд для оптимизации и генерации кода.

## 3. Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?

| Характеристика | AST | LLVM IR |
|---------------|-----|---------|
| Уровень абстракции | Высокий (близко к исходному коду) | Низкий (ближе к машинному коду) |
| Зависимость от языка | Зависит | Независимо |
| Структура | Древовидная | Линейная (SSA-форма) |
| Основное назначение | Семантический анализ | Оптимизация и кодогенерация |

## 4. Для чего необходимо промежуточное представление (IR) в процессе компиляции?

Промежуточное представление необходимо для:
- Унификации обработки разных языков программирования
- Применения общих оптимизаций
- Отделения фронтенда (анализа кода) от бэкенда (генерации кода)
- Упрощения процесса оптимизации

## 5. Что делает инструкция `alloca` в LLVM IR?

Инструкция `alloca`:
- Выделяет память в стеке функции для локальных переменных
- Используется в неоптимизированном коде (-O0)
- Удаляется оптимизатором при переходе к SSA-форме

## 6. Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?
### Цели:

- Ускорение выполнения: Удаление избыточных операций (например, свёртка констант).
- Уменьшение размера кода: Удаление мёртвого кода (-dce).
- Улучшение предсказуемости: Оптимизация ветвлений (-simplifycfg).
- Эффективное использование ресурсов: Работа с регистрами вместо памяти (-mem2reg).

Пример: В задании square(5) превратилось в 25 на этапе компиляции.

## 7. Что такое SSA-форма и почему она важна при оптимизации программ?
SSA (Static Single Assignment) — это форма промежуточного представления программы, в которой каждая переменная присваивается ровно один раз, а каждое новое присваивание создаёт новую версию переменной (например, x1, x2). Для объединения значений переменных в точках слияния (например, после условных переходов) используются специальные φ-функции, которые выбирают правильное значение в зависимости от пути выполнения.

Важность SSA для оптимизации:

- Упрощение анализа данных: Поскольку каждая переменная имеет уникальное присваивание, легче отслеживать зависимости данных и определять, где и как используется значение.
- Эффективные оптимизации: SSA облегчает такие оптимизации, как удаление мёртвого кода, распространение констант и анализ живучести переменных, так как зависимости между переменными становятся явными.
- Улучшение точности: φ-функции позволяют точно моделировать потоки данных в точках слияния, что улучшает анализ и оптимизацию в сложных конструкциях (например, циклах или ветвлениях).
- Универсальность: SSA-форма позволяет компилятору применять одинаковые алгоритмы оптимизации независимо от структуры программы.

Пример: Вместо x = 1; x = x + 2; в SSA будет x1 = 1; x2 = x1 + 2;, что упрощает анализ.

## 8. Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?
Граф потока управления (Control Flow Graph, CFG) — это направленный граф, представляющий структуру управления программы. Узлы графа — это базовые блоки (последовательности инструкций без ветвлений), а рёбра — переходы между ними (например, условные или безусловные переходы).

Как CFG помогает анализировать поведение программы:

- Анализ достижимости: CFG позволяет определить, какие части программы могут быть выполнены, выявляя недостижимый (мёртвый) код.
- Оптимизация ветвлений: Анализ CFG помогает упростить сложные конструкции управления, такие как избыточные переходы или неиспользуемые ветки.
- Анализ зависимостей: CFG используется для анализа потока данных, чтобы понять, как данные передаются между базовыми блоками.
- Обнаружение циклов: CFG помогает выявить циклы в программе, что важно для оптимизаций, таких как распараллеливание или инвариантный подъём.
- Упрощение оптимизаций: CFG предоставляет структурированное представление программы, что делает возможным такие оптимизации, как свёртка констант или реорганизация кода.

Пример: В CFG условный оператор if будет представлен как узел с двумя исходящими рёбрами (для веток true и false), что позволяет анализировать оба пути выполнения.

## 9. Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?
Формат: ``` %result = op <тип> <операнд1>, <операнд2> ```

Примеры:
```
llvm
%sum = add i32 %a, %b      ; Сложение
%mul = mul nsw i32 %x, %x  ; Умножение (nsw — no signed wrap)
%div = sdiv i32 %y, 2      ; Деление
```

## 10. Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?
- Изоляция: Функции имеют чёткие границы (аргументы, возвращаемое значение).
- Модульность: Оптимизации (например, -inline) работают на уровне функций.
- Повторное использование: Функции могут быть вызваны из разных мест программы.


## 11. Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?
- Встраивание (-inline): Тело функции подставляется в место вызова.
- Удаление: Если функция больше не используется, она исключается из кода.

Пример из задания:

До: main вызывал square(5).

После: square встроена, вычисление заменено на 25.

## 12. Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?

- Универсальность: IR не зависит от языка (C, Rust и т.д.).
- Низкоуровневость: Чёткая структура инструкций упрощает анализ.
- SSA-форма: Позволяет точно отслеживать зависимости данных.
- Визуализация: CFG показывает поток управления, что полезно для оптимизаций.

Пример:

В исходном коде square(a) требует анализа контекста.

В IR: %2 = mul nsw i32 %0, %0 — явная инструкция для оптимизации.


# Дополнительное задание
Вариант 9. Создание функции языка C/C++
Задание: Напишите функцию double average(int a, int b) и вызовите её
из main(). Постройте её CFG и определите, где можно провести
оптимизации.

# Ход работы
### 1. Исходный код
```C
#include <stdio.h>

double average(int a, int b) {
    return (a + b) / 2.0;
}

int main() {
    int x = 10, y = 20;
    double result = average(x, y);
    printf("Average: %f\n", result);
    return 0;
}
```
![image](https://github.com/user-attachments/assets/002221e3-7179-428c-a7a5-a1968157abaa)

### 2. Получение AST

```bash
clang -Xclang -ast-dump -fsyntax-only average.c
```
![image](https://github.com/user-attachments/assets/dd8bda8c-861b-4012-bade-9c867ccd5d75)

### 3. Генерация LLVM IR

```bash
clang -S -emit-llvm main.c -o average.ll
```

![image](https://github.com/user-attachments/assets/3a3ecb28-a06b-4ccb-ba7d-af4ecf26738b)


### 4. Оптимизация IR


```bash
clang -O0 -S -emit-llvm average.c -o average_O0.ll
```
![image](https://github.com/user-attachments/assets/2f880d94-b964-4af5-8958-4c1b8b0991e5)


```bash
clang -O2 -S -emit-llvm average.c -o average_O2.ll
```
![image](https://github.com/user-attachments/assets/aa3452f5-3ba6-44ab-b110-1ff5fc2aa648)


**Сравнение (diff):**
```bash
diff average_O0.ll average_O2.ll
```
![image](https://github.com/user-attachments/assets/20d8cef4-bb50-4bbc-9f5f-26736bafe583)

### 5. Граф потока управления программы

```bash
opt -passes=dot-cfg -disable-output average_O2.ll
dot -Tpng .main.dot -o cfg_main.png
dot -Tpng .average.dot -o cfg_average.png
```
![cfg_main](https://github.com/user-attachments/assets/a19a8a36-c203-4f1e-a0a0-7c393cccaadd)
![cfg_average](https://github.com/user-attachments/assets/30c66b71-7f2e-4e66-b8f9-e38902c98e9d)













